// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: queries.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createAnalysis = `-- name: CreateAnalysis :one
INSERT INTO analyses (codebase_id, commit_sha, branch_name, status, started_at)
VALUES ($1, $2, $3, $4, $5)
RETURNING id, codebase_id, commit_sha, branch_name, status, error_message, started_at, completed_at, created_at, total_suites, total_tests
`

type CreateAnalysisParams struct {
	CodebaseID pgtype.UUID        `json:"codebase_id"`
	CommitSha  string             `json:"commit_sha"`
	BranchName pgtype.Text        `json:"branch_name"`
	Status     AnalysisStatus     `json:"status"`
	StartedAt  pgtype.Timestamptz `json:"started_at"`
}

func (q *Queries) CreateAnalysis(ctx context.Context, arg CreateAnalysisParams) (Analysis, error) {
	row := q.db.QueryRow(ctx, createAnalysis,
		arg.CodebaseID,
		arg.CommitSha,
		arg.BranchName,
		arg.Status,
		arg.StartedAt,
	)
	var i Analysis
	err := row.Scan(
		&i.ID,
		&i.CodebaseID,
		&i.CommitSha,
		&i.BranchName,
		&i.Status,
		&i.ErrorMessage,
		&i.StartedAt,
		&i.CompletedAt,
		&i.CreatedAt,
		&i.TotalSuites,
		&i.TotalTests,
	)
	return i, err
}

const createTestCase = `-- name: CreateTestCase :one
INSERT INTO test_cases (suite_id, name, line_number, status, tags, modifier)
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id, suite_id, name, line_number, status, tags, modifier
`

type CreateTestCaseParams struct {
	SuiteID    pgtype.UUID `json:"suite_id"`
	Name       string      `json:"name"`
	LineNumber pgtype.Int4 `json:"line_number"`
	Status     TestStatus  `json:"status"`
	Tags       []byte      `json:"tags"`
	Modifier   pgtype.Text `json:"modifier"`
}

func (q *Queries) CreateTestCase(ctx context.Context, arg CreateTestCaseParams) (TestCase, error) {
	row := q.db.QueryRow(ctx, createTestCase,
		arg.SuiteID,
		arg.Name,
		arg.LineNumber,
		arg.Status,
		arg.Tags,
		arg.Modifier,
	)
	var i TestCase
	err := row.Scan(
		&i.ID,
		&i.SuiteID,
		&i.Name,
		&i.LineNumber,
		&i.Status,
		&i.Tags,
		&i.Modifier,
	)
	return i, err
}

const createTestSuite = `-- name: CreateTestSuite :one
INSERT INTO test_suites (analysis_id, parent_id, name, file_path, line_number, framework, depth)
VALUES ($1, $2, $3, $4, $5, $6, $7)
RETURNING id, analysis_id, parent_id, name, file_path, line_number, framework, depth
`

type CreateTestSuiteParams struct {
	AnalysisID pgtype.UUID `json:"analysis_id"`
	ParentID   pgtype.UUID `json:"parent_id"`
	Name       string      `json:"name"`
	FilePath   string      `json:"file_path"`
	LineNumber pgtype.Int4 `json:"line_number"`
	Framework  pgtype.Text `json:"framework"`
	Depth      int32       `json:"depth"`
}

func (q *Queries) CreateTestSuite(ctx context.Context, arg CreateTestSuiteParams) (TestSuite, error) {
	row := q.db.QueryRow(ctx, createTestSuite,
		arg.AnalysisID,
		arg.ParentID,
		arg.Name,
		arg.FilePath,
		arg.LineNumber,
		arg.Framework,
		arg.Depth,
	)
	var i TestSuite
	err := row.Scan(
		&i.ID,
		&i.AnalysisID,
		&i.ParentID,
		&i.Name,
		&i.FilePath,
		&i.LineNumber,
		&i.Framework,
		&i.Depth,
	)
	return i, err
}

const getCodebaseByID = `-- name: GetCodebaseByID :one
SELECT id, host, owner, name, default_branch, created_at, updated_at FROM codebases WHERE id = $1
`

func (q *Queries) GetCodebaseByID(ctx context.Context, id pgtype.UUID) (Codebasis, error) {
	row := q.db.QueryRow(ctx, getCodebaseByID, id)
	var i Codebasis
	err := row.Scan(
		&i.ID,
		&i.Host,
		&i.Owner,
		&i.Name,
		&i.DefaultBranch,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getTestCasesBySuiteID = `-- name: GetTestCasesBySuiteID :many
SELECT id, suite_id, name, line_number, status, tags, modifier FROM test_cases WHERE suite_id = $1 ORDER BY line_number
`

func (q *Queries) GetTestCasesBySuiteID(ctx context.Context, suiteID pgtype.UUID) ([]TestCase, error) {
	rows, err := q.db.Query(ctx, getTestCasesBySuiteID, suiteID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []TestCase{}
	for rows.Next() {
		var i TestCase
		if err := rows.Scan(
			&i.ID,
			&i.SuiteID,
			&i.Name,
			&i.LineNumber,
			&i.Status,
			&i.Tags,
			&i.Modifier,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTestSuitesByAnalysisID = `-- name: GetTestSuitesByAnalysisID :many
SELECT id, analysis_id, parent_id, name, file_path, line_number, framework, depth FROM test_suites WHERE analysis_id = $1 ORDER BY file_path, line_number
`

func (q *Queries) GetTestSuitesByAnalysisID(ctx context.Context, analysisID pgtype.UUID) ([]TestSuite, error) {
	rows, err := q.db.Query(ctx, getTestSuitesByAnalysisID, analysisID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []TestSuite{}
	for rows.Next() {
		var i TestSuite
		if err := rows.Scan(
			&i.ID,
			&i.AnalysisID,
			&i.ParentID,
			&i.Name,
			&i.FilePath,
			&i.LineNumber,
			&i.Framework,
			&i.Depth,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateAnalysisCompleted = `-- name: UpdateAnalysisCompleted :exec
UPDATE analyses
SET status = 'completed', total_suites = $2, total_tests = $3, completed_at = $4
WHERE id = $1
`

type UpdateAnalysisCompletedParams struct {
	ID          pgtype.UUID        `json:"id"`
	TotalSuites int32              `json:"total_suites"`
	TotalTests  int32              `json:"total_tests"`
	CompletedAt pgtype.Timestamptz `json:"completed_at"`
}

func (q *Queries) UpdateAnalysisCompleted(ctx context.Context, arg UpdateAnalysisCompletedParams) error {
	_, err := q.db.Exec(ctx, updateAnalysisCompleted,
		arg.ID,
		arg.TotalSuites,
		arg.TotalTests,
		arg.CompletedAt,
	)
	return err
}

const updateAnalysisFailed = `-- name: UpdateAnalysisFailed :exec
UPDATE analyses
SET status = 'failed', error_message = $2, completed_at = $3
WHERE id = $1
`

type UpdateAnalysisFailedParams struct {
	ID           pgtype.UUID        `json:"id"`
	ErrorMessage pgtype.Text        `json:"error_message"`
	CompletedAt  pgtype.Timestamptz `json:"completed_at"`
}

func (q *Queries) UpdateAnalysisFailed(ctx context.Context, arg UpdateAnalysisFailedParams) error {
	_, err := q.db.Exec(ctx, updateAnalysisFailed, arg.ID, arg.ErrorMessage, arg.CompletedAt)
	return err
}

const upsertCodebase = `-- name: UpsertCodebase :one
INSERT INTO codebases (host, owner, name, default_branch)
VALUES ($1, $2, $3, $4)
ON CONFLICT (host, owner, name)
DO UPDATE SET
    default_branch = COALESCE(EXCLUDED.default_branch, codebases.default_branch),
    updated_at = now()
RETURNING id, host, owner, name, default_branch, created_at, updated_at
`

type UpsertCodebaseParams struct {
	Host          string      `json:"host"`
	Owner         string      `json:"owner"`
	Name          string      `json:"name"`
	DefaultBranch pgtype.Text `json:"default_branch"`
}

func (q *Queries) UpsertCodebase(ctx context.Context, arg UpsertCodebaseParams) (Codebasis, error) {
	row := q.db.QueryRow(ctx, upsertCodebase,
		arg.Host,
		arg.Owner,
		arg.Name,
		arg.DefaultBranch,
	)
	var i Codebasis
	err := row.Scan(
		&i.ID,
		&i.Host,
		&i.Owner,
		&i.Name,
		&i.DefaultBranch,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
